import type { SpendingCategory, CategorySpending, SubcategorySpending } from "@/lib/types/spending";
import { CATEGORY_LABELS, CATEGORY_COLORS } from "@/lib/utils/constants";

// These will be loaded from pre-calculated JSON files at runtime
// The JSON files are generated by the scripts/ pipeline
let spendingData: SpendingDataFile | null = null;
let censusData: CensusDataFile | null = null;
let crosswalkData: CrosswalkDataFile | null = null;

interface SpendingDataFile {
  fiscalYear: string;
  counties: Record<string, {
    county: string;
    totalSpending: number;
    byCategory: Record<SpendingCategory, number>;
    byAgency: Record<string, { name: string; amount: number; category: SpendingCategory }>;
    byExpenditureType: Record<string, number>;
  }>;
}

interface CensusDataFile {
  stateMedianIncome: number;
  statePopulation: number;
  counties: Record<string, {
    countyFips: string;
    countyName: string;
    population: number;
    medianHouseholdIncome: number;
  }>;
}

interface CrosswalkDataFile {
  crosswalk: Record<string, {
    zipCode: string;
    countyName: string;
    countyFips: string;
  }>;
}

async function loadData() {
  if (!spendingData) {
    try {
      spendingData = (await import("@/data/spending-by-county.json")).default as unknown as SpendingDataFile;
    } catch {
      throw new Error("spending-by-county.json not found. Run: npx tsx scripts/fetch-spending.ts");
    }
  }
  if (!censusData) {
    try {
      censusData = (await import("@/data/census-data.json")).default as unknown as CensusDataFile;
    } catch {
      throw new Error("census-data.json not found. Run: npx tsx scripts/fetch-census.ts");
    }
  }
  if (!crosswalkData) {
    try {
      crosswalkData = (await import("@/data/zip-county-crosswalk.json")).default as unknown as CrosswalkDataFile;
    } catch {
      throw new Error("zip-county-crosswalk.json not found. Run: npx tsx scripts/build-crosswalk.ts");
    }
  }

  return { spending: spendingData!, census: censusData!, crosswalk: crosswalkData! };
}

export async function getCountyForZip(zipCode: string): Promise<{
  countyName: string;
  countyFips: string;
} | null> {
  const { crosswalk } = await loadData();
  const entry = crosswalk.crosswalk[zipCode];
  return entry ? { countyName: entry.countyName, countyFips: entry.countyFips } : null;
}

export async function getCountySpending(countyName: string): Promise<{
  totalSpending: number;
  byCategory: Record<SpendingCategory, number>;
  byAgency: Record<string, { name: string; amount: number; category: SpendingCategory }>;
  fiscalYear: string;
} | null> {
  const { spending } = await loadData();
  const county = spending.counties[countyName.toUpperCase()];
  if (!county) return null;

  return {
    totalSpending: county.totalSpending,
    byCategory: county.byCategory,
    byAgency: county.byAgency,
    fiscalYear: spending.fiscalYear,
  };
}

export async function getCountyCensus(countyName: string): Promise<{
  population: number;
  medianHouseholdIncome: number;
  countyFips: string;
} | null> {
  const { census } = await loadData();
  const county = census.counties[countyName.toUpperCase()];
  if (!county) return null;

  return {
    population: county.population,
    medianHouseholdIncome: county.medianHouseholdIncome,
    countyFips: county.countyFips,
  };
}

export async function getStateMedianIncome(): Promise<number> {
  const { census } = await loadData();
  return census.stateMedianIncome;
}

export async function getFiscalYear(): Promise<string> {
  const { spending } = await loadData();
  return spending.fiscalYear;
}

/**
 * Build CategorySpending[] from raw by-category and by-agency data.
 */
export function buildCategoryBreakdown(
  byCategory: Record<SpendingCategory, number>,
  byAgency: Record<string, { name: string; amount: number; category: SpendingCategory }>,
  population: number
): CategorySpending[] {
  const totalSpending = Object.values(byCategory).reduce((a, b) => a + b, 0);

  const categories: SpendingCategory[] = [
    "education",
    "health",
    "transportation",
    "public_safety",
    "other",
  ];

  return categories.map((cat) => {
    const amount = byCategory[cat] || 0;
    const perCapita = population > 0 ? amount / population : 0;
    const percentage = totalSpending > 0 ? (amount / totalSpending) * 100 : 0;

    // Build subcategories from individual agencies in this category
    const agenciesInCategory = Object.entries(byAgency)
      .filter(([, info]) => info.category === cat)
      .sort(([, a], [, b]) => b.amount - a.amount);

    const subcategories: SubcategorySpending[] = agenciesInCategory
      .slice(0, 8) // Top 8 agencies per category
      .map(([, info]) => ({
        name: info.name,
        amount: info.amount,
        perCapita: population > 0 ? info.amount / population : 0,
        percentage: amount > 0 ? (info.amount / amount) * 100 : 0,
      }));

    // If there are more agencies, group them as "Other"
    if (agenciesInCategory.length > 8) {
      const otherAmount = agenciesInCategory
        .slice(8)
        .reduce((sum, [, info]) => sum + info.amount, 0);
      subcategories.push({
        name: "Other Agencies",
        amount: otherAmount,
        perCapita: population > 0 ? otherAmount / population : 0,
        percentage: amount > 0 ? (otherAmount / amount) * 100 : 0,
      });
    }

    return {
      category: cat,
      label: CATEGORY_LABELS[cat],
      totalAmount: amount,
      perCapita: Math.round(perCapita),
      percentage: Math.round(percentage * 10) / 10,
      color: CATEGORY_COLORS[cat],
      subcategories,
    };
  });
}
